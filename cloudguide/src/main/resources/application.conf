cloudguide {
    timeouts {
      http-to-router = 60s
      router-to-llm  = 90s
    }
    llm {
      backend = "openai"       
    }
    openai {
      base-url = "https://api.openai.com/v1"
      model    = "gpt-4o-mini"
    }
    ollama {
      model = "llama3.2:1b"
      base-url = "http://localhost:11434"
      embed-model = "nomic-embed-text"
    }
    rag {
      store = "qdrant"  
      topK = 4
      max-context-chars = 3000
    }
    qdrant {
      host = "localhost"        
      port = 6333               
      collection = "cloudguide_docs"

      dim = 768

      distance = "Cosine"       
      upsert-batch = 64         # how many points per upsert batch
      timeout = 10s             # HTTP timeout for Qdrant calls

      # If Qdrant is unavailable at startup:
      # when true, fall back to in-memory store 
      # when false, fail fast so you notice the issue
      allow-fallback-to-memory = true
    }
}

akka.http.server.request-timeout = 120s

akka {
  loglevel = "INFO"
  loggers = ["akka.event.slf4j.Slf4jLogger"]
  logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"

  actor {
    provider = cluster

    allow-java-serialization = off
    warn-about-java-serializer-usage = on

    serialization-bindings {
      "com.cloudguide.CborSerializable" = jackson-cbor
    }
  }

  serialization.jackson {
    jackson-cbor { }
  }

  remote.artery {
    transport = tcp
    canonical.hostname = ${?HOST}     
    canonical.port     = ${?PORT}     
  }

  cluster {
    seed-nodes = [
      "akka://CloudGuideSystem@127.0.0.1:2551",
      "akka://CloudGuideSystem@127.0.0.1:2552"
    ]

    roles = [ ${?ROLE} ]

    log-info = on
    log-info-verbose = on

    min-nr-of-members = 1

    downing-provider-class = "akka.cluster.sbr.SplitBrainResolverProvider"
    split-brain-resolver {
      active-strategy = keep-majority
      stable-after = 7s
    }
  }
}
